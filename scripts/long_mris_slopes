#!/usr/bin/env python
# -*- coding: latin-1 -*-

#
# long_mris_slopes
#
# script to fit within-subject slopes into longitudinal data
#
# Original Author: Martin Reuter
# CVS Revision Info:
#    $Author: mreuter $
#    $Date: 2011/05/12 16:12:52 $
#    $Revision: 1.15.2.9 $
#
# Copyright Â© 2011 The General Hospital Corporation (Boston, MA) "MGH"
#
# Terms and conditions for use, reproduction, distribution and contribution
# are found in the 'FreeSurfer Software License Agreement' contained
# in the file 'LICENSE' found in the FreeSurfer distribution, and here:
#
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
#
# Reporting: freesurfer@nmr.mgh.harvard.edu
#
#

import warnings
warnings.filterwarnings('ignore', '.*negative int.*')
import os
import sys
import shlex
import optparse
import logging
import subprocess
import tempfile
import shutil
from subject_info import *
from LongQdecTable import *

# logging 
ch = logging.StreamHandler()
#create logger
slopelogger = logging.getLogger("long_mris_slopes")
slopelogger.setLevel(logging.INFO)
slopelogger.addHandler(ch)


HELPTEXT = """

SUMMARY

Computes slope maps (e.g. of thickness) in a longitudinal study.
The slope is computed within subject from the longitudinally processed
results (taken from the <tpNid>.long.<template> directories) and the
output is written into the subjects <template>/surf directory for further
processing (e.g. group analysis). Will also output the intersections of
all within-subject cortex labels in <template>/label/?h.long.cortex.label
if an input label is not specified with --inlabel <name> or if no different
output name is specified with --outlabel <name> .


REQUIRED ARGUMENTS

--qdec <name>      qdec.table.dat file with first columns: fsid  fsid-base

--meas <name>      Input curv file, e.g. thickness (except if only --do-label)

--hemi ?h          Hemisphere (lh or rh)


One or more of the following:

--do-avg           Compute and output the temporal average (recommended)

--do-rate          Compute and output the rate (recommended)

--do-pc1           Compute and output the pct. change (w.r.t. tp1)

--do-spc           Compute and output the sym. pct. change (w.r.t. temp. average) (recommended)

--do-label         Compute and output intersected cortex label (recommended)


OPTIONAL ARGUMENTS

--do-stack         Save the stacked within subject file (time series) (recommended)

--fwhm <int>       Smooth the data (recommended for percent change maps)

--nosmooth         Do not smooth (to overwrite smoothing requirement for pc1 or spc)

--time <name>      Variable name of time variable (e.g. age)

--in-label <name>  Use pre-existing label for smoothing (default: intersect cortex labels)

--qcache <qtarget> Create cache for qdec (resample to subject <qtarget>, e.g. fsaverage, and smooth at differnt levels)


To manually specify the subject specific output in <template>/surf/<hemi>.<name> :

--out-avg <name>   Output filename (without hemi ?h) for temporal average (default: long.<meas>-avg.mgh)

--out-rate <name>  Output filename for the rate (diff per time) (default: long.<meas>-rate.mgh)

--out-pc1 <name>   Output filename for percent change (w.r.t. time 1) (default: long.<meas>-pc1.mgh)

--out-spc <name>   Output filename for sym. pct. change (w.r.t. average) (default: long.<meas>-spc.mgh)

--out-stack <name> Store stacked measure file <template>/surf/<hemi>.<name> (default: long.<meas>-stack.mgh)

--out-label <name> Store intersected cortex in <template>/label/<hemi>.<name>.label (default: long.cortex)


To ouput stacked/intersected results on the qtarget (all require --qcache) :

--isec-labels <name> Intersect labels on <qtarget> (usually cortex labels)

--stack-avg <name>   Output stacked avg maps on <qtarget> for all fwhm levels

--stack-rate <name>  Output stacked rate maps on <qtarget> for all fwhm levels

--stack-pc1 <name>   Output stacked pc1 maps on <qtarget> for all fwhm levels

--stack-spc <name>   Output stacked spc maps on <qtarget> for all fwhm levels



DETAILS
=======


QDEC.TABLE
==========
Pass a qdec table file, where the first 2 columns need to be 'fsid  fsid-base'.
fsid is the id of the individual time points an 'fsid-base' the template/base
id (grouping the timepoints that belong to the same subject). By default the
third column is taken as the time variable, but this can be overwritten with
--time <name>. 

QDEC.TABLE-EXAMPLE:
fsid    fsid-base  age   weight   IQ
Elmo_1   Elmo       3      10    1000        
#Elmo_2  Elmo       3.5    15    1100
Elmo_3   Elmo       4      20    1300 
Snuffy_1 Snuffy    20      40    1100
Snuffy_2 Snuffy    21      45    1200
Bert_1   Bert       8      25    2000
Bert_2   Bert       9      30    2500
Bert_3   Bert       9.9    34    2400

If you like, you can create an independent qdec table file for each subject,
containing only the time points of that subject (e.g. to process stuff
simultaneously). You can also run left and right hemisphere at the same time.


OUTPUT
======
The output will be written into the template surf directory (unless qcache
is used):

<template>/surf/<hemi>.<NAME>(.fwhm<fwhm>).mgh

Choose one or more of the following options:
*  'do-rate' for rate, this will compute the slope of a linear fit.
   Depending on the time variable will yield the thinning in mm/time
   (if the time variable is measured in years, such as age: mm/year).
*  'do-pc1' is the percent change, this is the rate normalized by the
   measure at the first time point times 100, e.g. percent thinning per year.
*  'do-spc' for symmetrized percent change. Here we normalize by the temporal
   average instead of taking it from the first time point. The average is
   computed from the linear fit at the middle of the time interval.
   This is a symmetric 'percent thinning per year' and more robust, as TP1
   can be an outlier.
*  'do-avg' for output of the temporal average (linear fit at mid time).

NOTE that for percent change (pc1 and spc) prior smoothing (--fwhm) is
highly recommended as the division can produce very large values!


CORTEX LABEL
============
It is recommended to specify --do-label which will intersect the cortex label
of all time point within a subject. The intersected label is stored to 
<template>/label/<HEMI>.<OUT_LABEL> (where default <OUT_LABEL>=long.cortex).
The <name> can be overwritten by --out-label <OUT_LABEL>.
If additionally --qcache and --isec-labels <name> is specified, these labels
will be mapped and intersected on the <qtarget> and output will be written
to <name>.


QCACHE
======
In order to run a group analysis with QDEC all surface measures need to be 
resampled to some target. If you plant to use QDEC, specify --qcache <qtarget>.
You can select the qtarget (needs to be in the subjectsdir), usually fsaverage
is fine, which is automatically created in the subjectsdir during recon-all.

If --qcache <qtarget> is specified, it will resample all the analyses
specified with --do-??? (and the labels if --do-label) to the qtarget. 

It will also work on different smoothing levels if --fwhm is NOT specified:
0,5,10,15,20,25
If --fwhm is specified it will only work on the specified level.
Smoothing will be done in the subject space before the division (spc or pc1).

Output can be found in <template>/surf folder under each subject template.
<template>/surf/<HEMI>.<NAME>(.fwhm<fwhm>).mgh  (for subject space)
<template>/surf/<HEMI>.<NAME>(.fwhm<fwhm>).<QTARGET>.mgh

If cortex labels are intersected (--do-label), it will also be mapped to
the qtarget and output as:
<template>/label/<HEMI>.<NAME>(.fwhm<fwhm>).<QTARGET>.mgh


EXAMPLES
========
Simply create avg, rate, pc1, spc for each subject. Also will output
the stacked thickness files and will intersect the cortex label. Here we
work on the left hemisphere (lh) and use smoothing of 15 fwhm. Note that
'age' is the column secifying the age in the long.qdec.table.dat file:

long_mris_slopes --qdec ./long.qdec.table.dat --meas thickness --hemi lh \
  --do-avg --do-rate --do-pc1 --do-spc --do-stack --do-label \
  --fwhm 15 --time age

or to create Qdec cache on fsaverage:

long_mris_slopes --qdec ./long.qdec.table.dat --meas thickness --hemi lh \
  --do-avg --do-rate --do-pc1 --do-spc --do-stack --do-label \
  --time age --qcache fsaverage
  
  
REFERENCES
==========
Highly Accurate Inverse Consistent Registration: A Robust Approach,
M. Reuter, H.D. Rosas, B. Fischl. NeuroImage 53 (4), pp. 1181-1196, 2010.
  http://dx.doi.org/10.1016/j.neuroimage.2010.07.020
  http://reuter.mit.edu/papers/reuter-robreg10.pdf 

Avoiding Asymmetry-Induced Bias in Longitudinal Image Processing,
M. Reuter, B. Fischl. NeuroImage, 2011.
  http://dx.doi.org/10.1016/j.neuroimage.2011.02.076
  http://reuter.mit.edu/papers/reuter-bias11.pdf 
 
"""



def options_parse():
    """
    Command Line Options Parser for long_mris_slopes
    initiate the option parser and return the parsed object
    """
    parser = optparse.OptionParser(version='$Id: long_mris_slopes,v 1.15.2.9 2011/05/12 16:12:52 mreuter Exp $', usage=HELPTEXT)
    
    # help text
#    h_fsgd = '(REQUIRED) fsdg file specifying the subjects and time points'
    h_qdec      = '(REQUIRED) qdec table file specifying the subjects and time points'
    h_meas      = '(REQUIRED) the surface input measure (e.g. thickness)'
    h_hemi      = '(REQUIRED) run one hemisphere: lh or rh'

    h_doavg     = 'compute and output the temporal average (recommended)'
    h_dorate    = 'compute and output the rate (recommended)'
    h_dopc1     = 'compute and output the pct. change (w.r.t. tp1)'
    h_dospc     = 'compute and output the sym. pct. change (w.r.t. temp. average) (recommended)'
    h_dostack   = 'save the stacked within subject file (time series)'
    h_dolabel   = 'compute and output intersected cortex label (recommended)'

    h_out_avg   = 'filename (without hemi ?h) to store temporal average in <template>/surf/<hemi>.<OUT_AVG>.mgh (default: long.<meas>-avg)'
    h_out_rate  = 'filename (without hemi ?h) to store rate in <template>/surf/<hemi>.<OUT_RATE>.mgh (default: long.<meas>-rate)'
    h_out_pc1   = 'filename (without hemi ?h) to store pct. change (to TP1) in <template>/surf/<hemi>.<OUT_PC1>.mgh (default: long.<meas>-pc1)'
    h_out_spc   = 'filename (without hemi ?h) to store sym. pct. change in <template>/surf/<hemi>.<OUT_SPC>.mgh (default: long.<meas>-spc)'
    h_outstack  = 'filename to store stacked measure file <template>/surf/<hemi>.<OUT_STACK>.mgh (default: long.<meas>-stack)'
    h_outlabel  = 'filename to store within-subject intersected cortex labels in <template>/label/<hemi>.<OUT_LABEL>.label (default: long.cortex)'

    h_fwhm      = 'smoothing at specific fwhm (required for pct. change)'
    h_nosmooth  = 'do not smooth the data (overwrite requirement to not smooth pct change computations)'    
    h_time      = 'variable name for time column variable (e.g. age) in qdec table'    
    h_inlabel   = 'use pre-existing label for smoothing and to mask the output'
    h_qcache    = 'create cache for qdec (resample to subject <QCACHE>, e.g. fsaverage, and smooth at differnt levels)'

    h_iseclabels= 'intersect labels on <qtarget> (usually cortex labels), requires --qcache'
    h_stackavg  = 'output stacked avg maps on <qtarget> for all fwhm levels, requires --qcache'
    h_stackrate = 'output stacked rate maps on <qtarget> for all fwhm levels, requires --qcache'
    h_stackpc1  = 'output stacked pc1 maps on <qtarget> for all fwhm levels, requires --qcache'
    h_stackspc  = 'output stacked spc maps on <qtarget> for all fwhm levels, requires --qcache'
    
#    h_outformat = 'Output format can be either mgh (default) or curv'
 
    # Add options 
#    parser.add_option('--fsgd', dest='fsgd', help=h_fsgd)

    # Sepcify inputs
    parser.add_option('--qdec', dest='qdec', help=h_qdec)
    parser.add_option('--meas', dest='meas', help=h_meas)
    parser.add_option('--hemi', dest='hemi', help=h_hemi, choices=('lh','rh'))

    # do computations:
    parser.add_option('--do-avg'  , action='store_true', dest='do_avg'  , help=h_doavg  , default=False)
    parser.add_option('--do-rate' , action='store_true', dest='do_rate' , help=h_dorate , default=False)
    parser.add_option('--do-pc1'  , action='store_true', dest='do_pc1'  , help=h_dopc1  , default=False)
    parser.add_option('--do-spc'  , action='store_true', dest='do_spc'  , help=h_dospc  , default=False)
    parser.add_option('--do-stack', action='store_true', dest='do_stack', help=h_dostack, default=False)
    parser.add_option('--do-label', action='store_true', dest='do_label', help=h_dolabel, default=False)
    
    # parameters:
    parser.add_option('--fwhm', dest='fwhm', help=h_fwhm)
    parser.add_option('--nosmooth', action='store_true', dest='nosmooth', help=h_nosmooth, default=False)
    parser.add_option('--time', dest='time', help=h_time)
    parser.add_option('--in-label' , dest='in_label' , help=h_inlabel)
    parser.add_option('--qcache' , dest='qcache' , help=h_qcache)
    
    # overwrite default output names:
    parser.add_option('--out-avg'  , dest='out_avg'  , help=h_out_avg)
    parser.add_option('--out-rate' , dest='out_rate' , help=h_out_rate)
    parser.add_option('--out-pc1'  , dest='out_pc1'  , help=h_out_pc1)
    parser.add_option('--out-spc'  , dest='out_spc'  , help=h_out_spc)
    parser.add_option('--out-stack', dest='out_stack', help=h_outstack)
    parser.add_option('--out-label', dest='out_label', help=h_outlabel, default="long.cortex")
    
    # stuff on common qcache target:
    parser.add_option('--isec-labels', dest='isec_labels', help=h_iseclabels)
    parser.add_option('--stack-avg'  , dest='stack_avg'  , help=h_stackavg)
    parser.add_option('--stack-rate' , dest='stack_rate' , help=h_stackrate)
    parser.add_option('--stack-pc1'  , dest='stack_pc1'  , help=h_stackpc1)
    parser.add_option('--stack-spc'  , dest='stack_spc'  , help=h_stackspc)
   

                      
    (options, args) = parser.parse_args()
    
    # extensive error checks
#    if options.fsgd is None and 
    if options.qdec is None:
#        print 'ERROR: Specify --fsgd or --qedc'
        print 'ERROR: Specify --qedc'
        print '       or run with --help for help.'
        sys.exit(1)

#    if options.fsgd is not None and options.qdec is not None:
#        print 'ERROR: Specify either --fsgd or --qedc, not both'
#        sys.exit(1)
        
    if options.hemi is None:
        print 'ERROR: Specify --hemi (e.g. \'lh\')'
        sys.exit(1)
 
    if options.do_avg and options.out_avg is None:
        options.out_avg = 'long.'+options.meas+'-avg'
    elif options.out_avg is not None:
        options.do_avg = True
    if options.do_rate and options.out_rate is None:
        options.out_rate = 'long.'+options.meas+'-rate'
    elif options.out_rate is not None:
        options.do_rate = True
    if options.do_pc1 and options.out_pc1 is None:
        options.out_pc1 = 'long.'+options.meas+'-pc1'
    elif options.out_pc1 is not None:
        options.do_pc1 = True
    if options.do_spc and options.out_spc is None:
        options.out_spc = 'long.'+options.meas+'-spc'
    elif options.out_spc is not None:
        options.do_spc = True
    if options.do_stack and options.out_stack is None:
        options.out_stack = 'long.'+options.meas+'-stack'
    elif options.out_stack is not None:
        options.do_stack = True

    do_analysis = options.do_avg or options.do_pc1 or options.do_spc or options.do_rate    
    if options.meas is None and do_analysis:
        print 'ERROR: Specify --meas (e.g. \'thickness\')'
        sys.exit(1)
    
    if options.meas is None: options.meas = "label" #needed later to create tmp dir

    # switch on do_label if output is specified but no input
    if options.isec_labels is not None and options.in_label is None:
        options.do_label = True 
           
    if not do_analysis and not options.do_label:
        print 'ERROR: Analysis type should be specified, use one or more of --do-avg, --do-rate, --do-pc1 or --do-spc or --do-label'
        sys.exit(1)
    
    if options.fwhm is not None and options.nosmooth:
        print 'ERROR: either specify --fwhm <int> or --nosmooth'
        sys.exit(1)
        
    if (options.out_pc1 is not None or options.out_spc is not None) and options.fwhm is None and not options.nosmooth and options.qcache is None:
        print 'ERROR: when computing SPC or PC1 (pct. change) you should specify smoothing --fwhm <int>. If you really do not want to smooth pass --nosmooth'
        sys.exit(1)
    
    if options.isec_labels is not None and options.qcache is None:
        print 'ERROR: --isec-labels requires target as specified with --qcache'
        sys.exit(1)
    
    return options


def write_fsgd(filename,subjects_tp_map,subject,timeidx):
    """
    Write the fsgd to disk. Initialize the writer class.
    """
    fp = open(filename, 'w')
    fp.write('GroupDescriptorFile 1\n')
    fp.write('Title MyLongStudy\n')
    fp.write('Class '+subject)
    fp.write('Variables            Time')
    
    for tp in subjects_tp_map[subject]:
        fp.write('Input '+tp[0]+' '+subject+' '+tp[timeidx]+'\n')
        
    fp.write('\n')
    fp.close()    


def run_cmd(cmd,err_msg):
    """
    execute the comand
    """
    print cmd+'\n'
    args = shlex.split(cmd)
    retcode = subprocess.call(args)
    if retcode != 0 :
        print 'ERROR '+str(retcode)+' : '+err_msg
        sys.exit(1)
    print '\n'

def intersect_labels(labellist,outlabel):
    # will intersect the labels in labelist (full paths)
    # and write the output to outlabel (full path)

    if os.path.exists(outlabel):
       os.remove(outlabel)

    for label in labellist:
        if not os.path.exists(label):
            print 'ERROR: '+str(label)+' does not exist!'
            sys.exit(1)
        
        if not os.path.exists(outlabel):
            cmd = 'cp '+label+' '+outlabel
        else:
            cmd = 'mris_label_calc intersect '+label+' '+outlabel+' '+outlabel
            
        run_cmd(cmd,'mris_label_calc intersect did not work?')
        if not os.path.exists(outlabel):
            print 'ERROR: Cannot write '+str(outlabel)+' (write permissions?)!'
            sys.exit(1)


def stack_map(srcid,trgid,src_type,trg_type,inlist,outlist,tmpdir,hemi):
    if len(inlist) != len(outlist):
        print 'ERROR: stack_map: in and outlist have different lengths!'
        sys.exit(1)        
    if len(inlist) ==0:
        print 'ERROR: stack_map: inlist should have at least one element!'
        sys.exit(1)        

    if len(inlist) == 1:
    
        # map stack to target
        trg1=os.path.join(tmpdir,hemi+'.tmp0000.mgh')
        cmd = 'mri_surf2surf --hemi '+hemi+' --srcsubject '+srcid+' --sval '+inlist[0]+' --src_type mgh --trgsubject '+trgid+' --tval '+trg1+' --trg_type mgh'
        run_cmd(cmd,'mri_surf2surf mapping single file to qcache target did not work?')
        
    
    else:

        allin = " ".join(inlist)
        
        # stack all measure files
        allstack=os.path.join(tmpdir,'allstack.mgh')    
        cmd = 'mri_concat --i '+allin+' --o '+allstack
        run_cmd(cmd,'mri_concat stacking all outputs') 
    
        # map stack to target
        trgstack=os.path.join(tmpdir,'trgstack.mgh')
        cmd = 'mri_surf2surf --hemi '+hemi+' --srcsubject '+srcid+' --sval '+allstack+' --src_type mgh --trgsubject '+trgid+' --tval '+trgstack+' --trg_type mgh'
        run_cmd(cmd,'mri_surf2surf mapping stack to qcache target did not work?')
    
        # split the stack
        outframe=os.path.join(tmpdir,hemi+'.tmp.mgh')
        cmd = 'mri_convert '+trgstack+' '+outframe+' --split'
        run_cmd(cmd,'mri_convert splitting qcache stack did not work?')

    # mv elements to final destination
    i=0
    for fn in outlist:
        istr= '%04d' % i
        tmpfn=os.path.join(tmpdir,hemi+'.tmp'+istr+'.mgh')
        if not os.path.exists(tmpfn):
            print 'ERROR: '+str(tmpfn)+' does not exist!'
            sys.exit(1)        
        cmd = 'mv '+tmpfn+' '+fn
        run_cmd(cmd,'mv '+tmpfn+' '+fn+'   did not work?')
        i=i+1



if __name__=="__main__":
    # Command Line options and error checking done here
    options = options_parse()
    slopelogger.debug('-- The options you entered --')
    slopelogger.debug(options) 

    subjectsdir = ''
    # Parse the stats files 
#    if options.fsgd is not None:
#        print 'Parsing the fsgd file: '+options.fsgd
#        try:
#            slopelogger.debug('Processing file ' + options.fsgd)
#            fsgdparse = FsgdParser(options.fsgd)
#            subjects_tp_map, variables, defaultvar = fsgdparse.parse()
#        except BadFileError, e:
#            print 'ERROR: fsgd file '+str(e)+' not found!'
#            sys.exit(1)
#    else:
    print 'Parsing the qdec table: '+options.qdec
    try:
        slopelogger.debug('Processing file ' + options.qdec)
        qdectable = LongQdecTable(options.qdec)
        #subjects_tp_map, variables, subjectdir = qdecparse.parse()
    except BadFileError, e:
        print 'ERROR: qdec table '+options.qdec+' not found!'
        sys.exit(1)
    
    # make sure we have a long table containing the bases
    if qdectable.cross:
        print '\nERROR: qdec table '+options.qdec+' is cross sectional\n       (2nd column not \'fsid-base\')!\n'
        sys.exit(1)
        
    # get other variables:
    variables=qdectable.variables
    if len(variables) < 1:
        print '\nERROR: qdec table '+options.qdec+' needs 3rd column with time value,'
        print '       e.g. age or time since baseline scan ...!\n'
        sys.exit(1)
        
    # use the first column by default for time variable
    varidx = 1

    # if time variable is passed on command line, make sure it is part of variables
    if not options.time is None:
        defaultvar = options.time
        # compute correct index (starting with 1, 0 is the tpID)
        foundidx = False
        for index in (i for i in xrange(len(variables)) if variables[i].upper()==defaultvar.upper()):
            varidx = index
            foundidx = True
            #print 'found: '+str(varidx)+' '+variables[varidx]
            break
        if not foundidx:
            print '\nERROR: DefaultVariable \''+str(defaultvar)+'\' not found in variables: '+str(variables)+'\n'
            sys.exit(1)
        varidx = varidx +1;
        
    # maybe later check if time column is really a float?

    # if env is set, overwrite info from file (if it was passed in qdec)
    subjectsdir = qdectable.subjectsdir
    sdir = os.getenv('SUBJECTS_DIR')
    if sdir is not None:
        subjectsdir = sdir
    print '\nWorking in SUBJECTS_DIR: '+subjectsdir+'\n'

    if options.qcache is not None:
        # check if qcache target exists
        qsdir = os.path.join(subjectsdir,options.qcache)
        if not os.path.exists(qsdir):
            print 'ERROR: Qcache Target dir '+str(qsdir)+' not found!'
            sys.exit(1)
    
    # process
    retcode = 0
    tlabels = []
    tavg    = {}
    trate   = {}
    tpc1    = {}
    tspc    = {}
    for subjectid, tplist in qdectable.subjects_tp_map.items():
        print '\nSubject-Template: '+subjectid
        
        # check if basedir exists
        basedir = os.path.join(subjectsdir,subjectid)
        if not os.path.exists(basedir):
            print '\nERROR: Template dir '+str(basedir)+' does not exist!\n '
            sys.exit(1)

        basesurfdir=os.path.join(basedir,'surf')
        #if options.qcache is not None:
        #    basesurfdir=os.path.join(basedir,'surf','qcache')
        #    if not os.path.exists(basesurfdir):
        #        os.mkdir(basesurfdir)
            
        
        # check if 2 or more time points
        if len(tplist) < 2 :
            print 'ERROR: '+str(basedir)+' must have at least 2 time points!'
            sys.exit(1)
        
        # extract ids and age data:
        tpids = [entry[0]+'.long.'+subjectid for entry in tplist]
        times = [float(entry[varidx]) for entry in tplist]
        num   = len(times)
        meant = sum(times) / num
        print '\n\nINFO: '+str(num)+' TPs in '+subjectid+' , mean age: '+str(meant)+'\n'
        
        # intersect cortex ?
        label=""
        if options.do_label: 
            print "\n==============================================================================="
            print "SUBJECT "+subjectid+"  Intersecting Within-Subject Cortex Label\n"
            label = options.hemi+'.'+options.out_label+'.label'
            label = os.path.join(basedir,'label',label)
            llist = [ os.path.join(subjectsdir,entry,'label',options.hemi+'.cortex.label') for entry in tpids]
            # ouput written to base: /label/<hemi>.<outlabel>.label , default outlabel=long.cortex
            intersect_labels(llist,label)
            
            # map label of this subject to common qcache target:
            if options.qcache is not None:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+"  mapping label to QCache\n"
                label = options.hemi+'.'+options.out_label+'.label'
                label = os.path.join(basedir,'label',label)
                outlabel = options.hemi+'.'+options.out_label+'.'+options.qcache+'.label'
                outlabel = os.path.join(basedir,'label',outlabel)
                cmd = 'mri_label2label --srclabel '+label+' --srcsubject '+subjectid+' --trglabel '+outlabel+' --trgsubject '+options.qcache
                cmd = cmd+' --regmethod surface --hemi '+options.hemi
                run_cmd(cmd,'mri_label2label mapping the label failed?') 
                tlabels.append(outlabel)
        
        if not (options.do_pc1 or options.do_avg or options.do_spc or options.do_rate):
            continue #only do label
        
        if options.in_label is not None:
            label = os.path.join(basedir,'label',options.in_label)
            if not os.path.exists(label):
                label = options.hemi+'.'+options.in_label
                label = os.path.join(basedir,'label',label)
                if not os.path.exists(label):
                    label = options.hemi+'.'+options.in_label+'.label'
                    label = os.path.join(basedir,'label',label)
                    if not os.path.exists(label):
                        print '\nERROR: cannot find '+options.in_label+' or '+label+'\n'
                        sys.exit(1)
            tlabels.append(label)
        
        # list of thickness files:
        measures=[os.path.join(subjectsdir,entry,'surf',options.hemi+'.'+options.meas) for entry in tpids]
        all = " ".join(measures)
        
        # create tmpdir:
        prefix = './tmp-'+subjectid+'_'+options.hemi+'_'+options.meas+'_'
        dirname = tempfile.mkdtemp('',prefix,'')
        if not os.path.exists(dirname):
            print 'ERROR: tmp dir '+str(dirname)+' cannot be created (write permissions?)!'
            sys.exit(1)
        
        # stack measure maps:
        meas_target = os.path.join(dirname,options.hemi+'.long.'+options.meas+'-stack.mgh')
        if options.do_stack:
            print "\n==============================================================================="
            print "SUBJECT "+subjectid+"  Stackinbg Within-Subject Maps\n"
            meas_target = os.path.join(basesurfdir,options.hemi+'.'+options.out_stack)
            if meas_target[-4:] != '.mgh':
                meas_target=meas_target+'.mgh'
        cmd = 'mri_concat '+all+' --o '+meas_target
        run_cmd(cmd,'mri_concat stacking did not work?')
        
#        # 2 tps, direct computation
#        if num == 2 :  
#        
#            # sort
#            if times[0] > times[1] :
#                times[0] , times[1] = times[1] , times[0]
#                measures[0] , measures[1] = measures[1], measures[0]
#                tpids[0], tpids[1] = tpids[1], tpids[0]
#
#            labelpara=""
#            if label != "" :
#                labelpara  = ' --label '+label
#        
#            # create difference:
#            beta1 = os.path.join(dirname,options.hemi+'.rate.'+options.meas)
#            cmd = 'mris_calc -o '+beta1+labelpara+' '+measures[1]+' sub '+measures[0]
#            run_cmd(cmd,'mri_calc difference did not work?')
#            cmd = 'mris_calc -o '+beta1+labelpara+' '+beta1+' div '+str(times[1]-times[0])
#            run_cmd(cmd,'mri_calc div did not work?')
#        
#            # create average for SPC or avg
#            beta0 = os.path.join(dirname,options.hemi+'.avg.'+options.meas)
#            cmd = 'mris_calc -o '+beta0+labelpara+' '+measures[0]+' add '+measures[1]
#            run_cmd(cmd,'mri_calc sum did not work?')
#            cmd = 'mris_calc -o '+beta0+' '+beta0+' mul 0.5'
#            run_cmd(cmd,'mri_calc mul 0.5 did not work?')
#
#            # convert to mgh format (to imitate glm)
#            beta0old = beta0
#            beta0 = os.path.join(dirname,'beta0.mgh') 
#            beta1old = beta1  
#            beta1 = os.path.join(dirname,'beta1.mgh')                
#            cmd = 'mri_convert '+beta0old+' '+beta0
#            run_cmd(cmd,'mri_convert did not work?')        
#            cmd = 'mri_convert '+beta1old+' '+beta1
#            run_cmd(cmd,'mri_convert did not work?')
#        
#        
#        else: # more than 2 time points, run GLM
        
        if 1==1:
            print "\n==============================================================================="
            print "SUBJECT "+subjectid+"  Running Within-Subject GLM\n"
            #write X-matrix (times):
            x_target    = os.path.join(dirname,'X-long.mat')
            print 'Writing '+x_target+' ...\n'
            if os.path.exists(x_target):
                os.remove(x_target)
            xfp = open(x_target, 'w')
            for time in times:
                xfp.write('1 '+str(time-meant)+'\n')
            xfp.close()    
        
            # run glm in tmp dir:
            zerodof=""
            if num==2:
                zerodof=" --allow-zero-dof "
            labelpara=""
            if label != "" :
                labelpara  = ' --label '+label
            glmdir=os.path.join(dirname,'glm')
            cmd = 'mri_glmfit --y '+meas_target+' --X '+x_target+zerodof+' --no-contrasts-ok --surf '+subjectid+' '+options.hemi+labelpara+' --glmdir '+glmdir
            run_cmd(cmd,'mri_glmfit did not work?')
        
            # harvest results (in beta.mgh)
            betafn = os.path.join(glmdir,'beta.mgh' )  
            beta0  = os.path.join(dirname,'beta0.mgh')  
            beta1  = os.path.join(dirname,'beta1.mgh') 
            if not os.path.exists(betafn):
                print 'ERROR: GLM results '+str(betafn)+' does not exist!'
                sys.exit(1)
            
            # split beta
            cmd = 'mri_convert --frame 0 '+betafn+' '+beta0 
            run_cmd(cmd,'mri_convert split frames 0 did not work?')
        
            cmd = 'mri_convert --frame 1 '+betafn+' '+beta1 
            run_cmd(cmd,'mri_convert split frames 1 did not work?')
        
        
        # either of the cases:        
        
        fwhms = [ 0 ] 
        if options.qcache is not None and options.fwhm is None:
            fwhms = [ 0 , 5, 10, 15, 20, 25 ]
        elif options.fwhm is not None:
            fwhms = [ options.fwhm ] 
            
        allout=[]
        alltout=[]
        for fwhm in fwhms:
        
            fwhmstr = ''
            if options.qcache is not None or fwhm > 0 :
                fwhmstr = '.fwhm'+str(fwhm)

            # do smoothing
            beta0fwhm = ''
            beta1fwhm = ''
            tp1fwhm   = ''
            if fwhm > 0:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+"  Smoothing at "+str(fwhm)+"\n"
                smooth = ' --fwhm '+str(fwhm)+' --smooth-only'
                labelpara=""
                if label != "" :
                    labelpara  = ' --label '+label
                beta0fwhm = os.path.join(dirname,'beta0'+fwhmstr+'.mgh') 
                cmd = 'mris_fwhm --hemi '+options.hemi+' --s '+subjectid+' --i '+beta0+labelpara+smooth+' --o '+beta0fwhm
                run_cmd(cmd,'mris_fwhm smoothing did not work?')
                beta1fwhm = os.path.join(dirname,'beta1'+fwhmstr+'.mgh') 
                cmd = 'mris_fwhm --hemi '+options.hemi+' --s '+subjectid+' --i '+beta1+labelpara+smooth+' --o '+beta1fwhm
                run_cmd(cmd,'mris_fwhm smoothing did not work?')
                if options.do_pc1:
                    tp1fwhm =  os.path.join(dirname,'tp1'+fwhmstr+'.mgh') 
                    cmd = 'mris_fwhm --hemi '+options.hemi+' --s '+tpids[0]+' --i '+measures[0]+labelpara+smooth+' --o '+tp1fwhm
                    run_cmd(cmd,'mris_fwhm smoothing did not work?')
            else:
                beta0fwhm = beta0
                beta1fwhm = beta1
                if options.do_pc1:
                    tp1fwhm = os.path.join(dirname,'tp1.mgh') 
                    #cmd = 'mri_surf2surf --hemi '+options.hemi+' --s '+tpids[0]+' --sval '+measures[0]+' --src_type curv --tval '+tp1fwhm+' --trg_type mgh'
                    cmd = 'mri_convert '+measures[0]+' '+tp1fwhm
                    run_cmd(cmd,'mri_convert converting TP1 measure did not work?')
        
        
            # create ouput (depending on type)
            if options.do_spc:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+" fwhm "+str(fwhm)+"  computing SPC\n"
                outname = os.path.join(basesurfdir,options.hemi+'.'+options.out_spc+fwhmstr+'.mgh')
                # compute symmetrized pct change:
                cmd = 'mris_calc -o '+outname+' '+beta1fwhm+' div '+beta0fwhm
                run_cmd(cmd,'mris_calc compute sym. pct. change (spc) problem?')    
                cmd = 'mris_calc -o '+outname+' --label '+label+' '+outname+' mul 100'
                run_cmd(cmd,'mris_calc compute sym. pct. change (spc) problem?')    
                allout.append(outname)
                if options.qcache is not None:
                    outtname= os.path.join(basesurfdir,options.hemi+'.'+options.out_spc+fwhmstr+'.'+options.qcache+'.mgh')
                    alltout.append(outtname)
                    if fwhm not in tspc:
                        tspc[fwhm] = []
                    tspc[fwhm].append(outtname)

            if options.do_pc1:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+" fwhm "+str(fwhm)+"  computing PC1\n"
                outname = os.path.join(basesurfdir,options.hemi+'.'+options.out_pc1+fwhmstr+'.mgh')
                # compute pct change:
                cmd = 'mris_calc -o '+outname+' '+beta1fwhm+' div '+tp1fwhm
                run_cmd(cmd,'mris_calc compute percent change (pc1) problem?')
                cmd = 'mris_calc -o '+outname+' --label '+label+' '+outname+' mul 100'
                run_cmd(cmd,'mris_calc compute percent change (pc1) problem?')
                allout.append(outname)
                if options.qcache is not None:
                    outtname = os.path.join(basesurfdir,options.hemi+'.'+options.out_pc1+fwhmstr+'.'+options.qcache+'.mgh')
                    alltout.append(outtname)
                    if fwhm not in tpc1:
                        tpc1[fwhm] = []
                    tpc1[fwhm].append(outtname)
            
            if options.do_rate: 
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+" fwhm "+str(fwhm)+"  computing Rate\n"
                outname = os.path.join(basesurfdir,options.hemi+'.'+options.out_rate+fwhmstr+'.mgh')
                # mul 1 to remove everything outside the label:
                cmd = 'mris_calc -o '+outname+' --label '+label+' '+beta1fwhm+' mul 1'
                run_cmd(cmd,'mris_calc masking with label (rate)') 
                allout.append(outname)
                if options.qcache is not None:
                    outtname = os.path.join(basesurfdir,options.hemi+'.'+options.out_rate+fwhmstr+'.'+options.qcache+'.mgh')
                    alltout.append(outtname)
                    if fwhm not in trate:
                        trate[fwhm] = []
                    trate[fwhm].append(outtname)
            
            if  options.do_avg:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+" fwhm "+str(fwhm)+"  computing AVG\n"
                outname = os.path.join(basesurfdir,options.hemi+'.'+options.out_avg+fwhmstr+'.mgh')
                # mul 1 to remove everything outside the label:
                cmd = 'mris_calc -o '+outname+' --label '+label+' '+beta0fwhm+' mul 1'
                run_cmd(cmd,'mris_calc masking with label (avg)') 
                allout.append(outname)
                if options.qcache is not None:
                    outtname = os.path.join(basesurfdir,options.hemi+'.'+options.out_avg+fwhmstr+'.'+options.qcache+'.mgh')
                    alltout.append(outtname)
                    if fwhm not in tavg:
                        tavg[fwhm] = []
                    tavg[fwhm].append(outtname)

        # end iterate fwhm levels

        # now we have all outputs at all fwhm levels
        # if qcache, map them to target:
        if options.qcache is not None:
        
            # stack ALL measure files and map to template and unstack again:
            if len(allout) > 0:
                print "\n==============================================================================="
                print "SUBJECT "+subjectid+"  mapping all measure files to QCache (as stack)\n"
                stack_map(subjectid,options.qcache,'mgh','mgh', allout , alltout ,dirname,options.hemi)
           
                   
        # cleanup tmp dir:    
        shutil.rmtree(dirname)
                    
        if len(allout) > 0:   
            print 'You can look at the result with, e.g.:'
            print '  tksurfer '+subjectid+' '+options.hemi+' pial -overlay '+allout[-1]
            print
                  
    # end iterate subjects    
    
    # stuff on common qcache target:
    if options.qcache is not None:

        if options.isec_labels is not None:
            print "\n==============================================================================="
            print "Intersecting all lables in template QCache\n"
            # intersect labels on common qcache target:
            first=True
            for label in tlabels:
                if first:
                    cmd = 'cp '+label+' '+options.isec_labels
                    run_cmd(cmd,'cp first qcache label failed?')
                    first = False
                else:
                    cmd = "mris_label_calc intersect "+options.isec_labels+' '+label+' '+options.isec_labels
                    run_cmd(cmd,'mris_label_calc intersect failed?')
                    
            # erode a little
            tpial = os.path.join(subjectsdir,options.qcache,"surf",options.hemi+'.pial')
            if not os.path.exists(tpial):
                print 'ERROR: qtemplate pial '+str(tpial)+' does not exist!'
                sys.exit(1)
            cmd="mris_label_calc erode 2 "+options.isec_labels+" "+tpial+" "+options.isec_labels
            run_cmd(cmd,'mris_label_calc erode failed?')
    
        
        # stack maps on qcache geometry if wanted:
        if options.stack_spc is not None or options.stack_pc1 is not None or options.stack_avg is not None or options.stack_rate is not None:
            print "\n==============================================================================="
            print "Stacking all maps in template QCache\n"
        
            fwhms = [ 0 ] 
            if options.fwhm is None:
                fwhms = [ 0 , 5, 10, 15, 20, 25 ]
            elif options.fwhm is not None:
                fwhms = [ options.fwhm ] 
            
            for fwhm in fwhms:        
                fwhmstr = ''
                if fwhm > 0 :
                    fwhmstr = '.fwhm'+str(fwhm)
            
                # stack each type of measure for this fwhm:
                if options.stack_spc is not None:
                    allin   = " ".join(tspc[fwhm])
                    allstack=options.stack_spc
                    if allstack[-4:] == ".mgh": allstack = allstack[:-4]
                    allstack= allstack+fwhmstr+'.mgh'
                    cmd = 'mri_concat --i '+allin+' --o '+allstack
                    run_cmd(cmd,'mri_concat stacking qcache spc outputs at fwhm '+str(fwhm)+' failed?') 
                if options.stack_pc1 is not None:
                    allin   = " ".join(tpc1[fwhm])
                    allstack=options.stack_pc1
                    if allstack[-4:] == ".mgh": allstack = allstack[:-4]
                    allstack= allstack+fwhmstr+'.mgh'
                    cmd = 'mri_concat --i '+allin+' --o '+allstack
                    run_cmd(cmd,'mri_concat stacking qcache pc1 outputs at fwhm '+str(fwhm)+' failed?') 
                if options.stack_avg is not None:
                    allin   = " ".join(tavg[fwhm])
                    allstack=options.stack_avg
                    if allstack[-4:] == ".mgh": allstack = allstack[:-4]
                    allstack= allstack+fwhmstr+'.mgh'
                    cmd = 'mri_concat --i '+allin+' --o '+allstack
                    run_cmd(cmd,'mri_concat stacking qcache avg outputs at fwhm '+str(fwhm)+' failed?') 
                if options.stack_rate is not None:
                    allin   = " ".join(trate[fwhm])
                    allstack=options.stack_rate
                    if allstack[-4:] == ".mgh": allstack = allstack[:-4]
                    allstack= allstack+fwhmstr+'.mgh'
                    cmd = 'mri_concat --i '+allin+' --o '+allstack
                    run_cmd(cmd,'mri_concat stacking qcache rate outputs at fwhm '+str(fwhm)+' failed?') 
            
    
    # always exit with 0 exit code
    sys.exit(0)
